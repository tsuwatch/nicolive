// Generated by CoffeeScript 1.11.1
var chalk, cheerio, h1, net, ref, request, resultcode, url,
  slice = [].slice;

request = require('request');

cheerio = require('cheerio');

net = require('net');

chalk = require('chalk');

h1 = chalk.underline.magenta;

ref = require('../api'), url = ref.url, resultcode = ref.resultcode;

module.exports = function() {
  var args, callback, i, live_id, options, ref1;
  live_id = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
  options = (ref1 = args[0]) != null ? ref1 : {};
  return this.getPlayerStatus(live_id, options, (function(_this) {
    return function(error, body, playerStatus) {
      var addr, chunks, mail, port, premium, res_from, thread, user_id, version;
      if (error != null) {
        return callback(error);
      }
      _this.playerStatus = playerStatus;
      port = playerStatus.port, addr = playerStatus.addr, thread = playerStatus.thread, version = playerStatus.version, res_from = playerStatus.res_from, user_id = playerStatus.user_id, premium = playerStatus.premium, mail = playerStatus.mail;
      if (options.verbose) {
        console.log(h1('Connect to'), "http://" + addr + ":" + port + "/api/thread?thread=" + thread + "&version=" + version + "&res_from=" + res_from);
        console.log(h1('Or  static'), "http://" + addr + ":" + (port - 2725) + "/api/thread?thread=" + thread + "&version=" + version + "&res_from=" + res_from);
      }
      if (_this.viewer != null) {
        _this.viewer.destroy();
      }
      _this.viewer = net.connect(port, addr);
      _this.viewer.on('connect', function() {
        var comment;
        comment = cheerio('<thread />');
        comment.attr({
          thread: thread,
          version: version,
          res_from: res_from
        });
        comment.options.xmlMode = true;
        _this.viewer.write(comment.toString() + '\0');
        return _this.viewer.setEncoding('utf-8');
      });
      chunks = '';
      _this.viewer.on('data', function(buffer) {
        var anonymity, chunk, code, comment, comments, data, description, element, foundThread, j, len, ref2, ref3, resultcodeValue, results, ticket;
        chunk = buffer.toString();
        chunks += chunk;
        if (!chunk.match(/\0$/)) {
          return;
        }
        if (options.verbose) {
          console.log(h1('Received raw'), chunks);
        }
        data = cheerio('<data>' + chunks + '</data>');
        chunks = '';
        resultcodeValue = data.find('thread').attr('resultcode');
        if (resultcodeValue != null ? resultcodeValue.length : void 0) {
          ref2 = resultcode[resultcodeValue], code = ref2.code, description = ref2.description;
          foundThread = data.find('thread');
          ticket = foundThread.attr('ticket');
          if (!_this.test) {
            console.log(h1('Resultcode ' + resultcodeValue), code, description);
          }
          if (options.verbose && resultcodeValue === '0') {
            console.log(h1('Thread'), foundThread.attr());
            if (resultcodeValue === '0') {
              console.log(h1('Chat'), {
                thread: thread,
                ticket: ticket,
                mail: mail,
                user_id: user_id,
                premium: premium
              });
            }
          }
          _this.playerStatus.last_res = foundThread.attr('last_res');
          _this.attrs = {
            thread: thread,
            ticket: ticket,
            mail: mail,
            user_id: user_id,
            premium: premium
          };
          if (resultcodeValue === '0') {
            _this.viewer.emit('handshaked', _this.attrs, _this.playerStatus);
          } else {
            _this.viewer.emit('error', data.find('thread').toString());
          }
        }
        comments = data.find('chat');
        results = [];
        for (j = 0, len = comments.length; j < len; j++) {
          comment = comments[j];
          element = cheerio(comment);
          comment = {
            attr: element.attr(),
            text: element.text(),
            usericon: url.usericonEmptyURL
          };
          ref3 = comment.attr, anonymity = ref3.anonymity, user_id = ref3.user_id;
          if (anonymity == null) {
            if (user_id) {
              comment.usericon = url.usericonURL + user_id.slice(0, 2) + '/' + user_id + '.jpg';
            }
          }
          _this.viewer.emit('comment', comment);
          if (comment.attr.no > _this.playerStatus.comment_count) {
            results.push(_this.playerStatus.last_res = comment.attr.no);
          } else {
            results.push(void 0);
          }
        }
        return results;
      });
      return callback(null, _this.viewer);
    };
  })(this));
};
